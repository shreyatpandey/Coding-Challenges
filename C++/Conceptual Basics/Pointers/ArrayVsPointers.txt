Q1] Are Arrays and Pointers same? No, they are not

Question-1:-
#include <iostream>
#include <typeinfo>

void takes_pointer(int* pointer) {
  if (typeid(pointer) == typeid(int[])) std::cout << 'a';
  if (typeid(pointer) == typeid(int*)) std::cout << 'p';
}

void takes_array(int array[]) {
  if (typeid(array) == typeid(int[])) std::cout << 'a';
  if (typeid(array) == typeid(int*)) std::cout << 'p';
}

int main() {
  int* pointer = nullptr;
  int array[1];

  takes_pointer(array);
  takes_array(pointer);

  std::cout << (typeid(int*) == typeid(int[]));
}
//Reason:- 
Functions taking pointers can also be called with arrays, and vice versa. So are arrays and pointers the same? No.
If they aren't the same, why can both functions be called with both arguments?
First let's look at takes_pointer(array);. 
What happens here is usually referred to as the array "decaying" to a pointer.
To be a bit more precise, let's have a look at §[conv.array] in the C++ standard:
"An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be converted to a prvalue of type “pointer to T”."
array is of type "array of 1 int", which converts to a prvalue (temporary) of type "pointer to int".

Question-2:-
#include <iostream>
using namespace std;

size_t get_size_1(int* arr)
{
  
  return sizeof arr;
}

size_t get_size_2(int arr[])
{
  return sizeof arr;
}

size_t get_size_3(int (&arr)[10])
{
  return sizeof arr;
}

int main()
{
  int array[10];
  //Assume sizeof(int*) != sizeof(int[10])
  cout<<"get_size_1:"<<get_size_1(array)<<endl;
  cout<<"get_size_2:"<<get_size_2(array)<<endl;
  cout<<"get_size_3:"<<get_size_3(array)<<endl;
  cout << (sizeof(array) == get_size_1(array));
  cout << (sizeof(array) == get_size_2(array));
  cout << (sizeof(array) == get_size_3(array));
}
